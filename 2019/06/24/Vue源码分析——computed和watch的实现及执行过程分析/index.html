<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Vue源码分析——computed和watch的实现及执行过程分析 | maxy612的个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="接触Vue也有两年了，在工作中主要的技术栈也是vue。今天来聊下vue中computed和watch是怎么实现的。其中会涉及到vue的响应式系统，会在另一篇文章中介绍。 computed和watch的用法在使用vue时，我们会用到vue的众多配置项，其中就包括computed和watch。例如：1234567891011121314151617181920212223242526272829303">
<meta name="keywords" content="Vue">
<meta property="og:type" content="article">
<meta property="og:title" content="Vue源码分析——computed和watch的实现及执行过程分析">
<meta property="og:url" content="https://maxy612.github.io/2019/06/24/Vue源码分析——computed和watch的实现及执行过程分析/index.html">
<meta property="og:site_name" content="maxy612的个人博客">
<meta property="og:description" content="接触Vue也有两年了，在工作中主要的技术栈也是vue。今天来聊下vue中computed和watch是怎么实现的。其中会涉及到vue的响应式系统，会在另一篇文章中介绍。 computed和watch的用法在使用vue时，我们会用到vue的众多配置项，其中就包括computed和watch。例如：1234567891011121314151617181920212223242526272829303">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-05-25T11:31:00.535Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Vue源码分析——computed和watch的实现及执行过程分析">
<meta name="twitter:description" content="接触Vue也有两年了，在工作中主要的技术栈也是vue。今天来聊下vue中computed和watch是怎么实现的。其中会涉及到vue的响应式系统，会在另一篇文章中介绍。 computed和watch的用法在使用vue时，我们会用到vue的众多配置项，其中就包括computed和watch。例如：1234567891011121314151617181920212223242526272829303">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner"></div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/interview">面试</a>
        
          <a class="main-nav-link" href="/life">生活</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about-md">关于我</a>
        
      </nav>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Vue源码分析——computed和watch的实现及执行过程分析" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/24/Vue源码分析——computed和watch的实现及执行过程分析/" class="article-date">
  <time datetime="2019-06-24T15:23:31.000Z" itemprop="datePublished">2019-06-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Vue源码分析——computed和watch的实现及执行过程分析
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>接触Vue也有两年了，在工作中主要的技术栈也是vue。今天来聊下vue中computed和watch是怎么实现的。其中会涉及到vue的响应式系统，会在另一篇文章中介绍。</p>
<h3 id="computed和watch的用法"><a href="#computed和watch的用法" class="headerlink" title="computed和watch的用法"></a>computed和watch的用法</h3><p>在使用vue时，我们会用到vue的众多配置项，其中就包括computed和watch。例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">'app'</span>&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; computedA &#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data() &#123;</span><br><span class="line">        a: <span class="number">1</span>,</span><br><span class="line">        b: <span class="number">2</span>,</span><br><span class="line">        c: &#123;</span><br><span class="line">            d: <span class="number">3</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    computed: &#123;</span><br><span class="line">        computedA() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="number">30</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    watch: &#123;</span><br><span class="line">        c: &#123;</span><br><span class="line">            deep: <span class="literal">true</span>,</span><br><span class="line">            handler(newVal, oldVal) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'newVal: '</span>, newVal);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        b(newVal, oldVal) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'newVal: '</span>, newVal);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)   </span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>当data中的a发生变化时，computedA也会重新计算获得最新的值。<br>当data中的c或b发生变化时，watch中对应的函数也会执行。</p>
<h3 id="computed和watch的实现"><a href="#computed和watch的实现" class="headerlink" title="computed和watch的实现"></a>computed和watch的实现</h3><p>翻开vue的源码，我们分析下computed和watch的实现。<br>Vue做为一个构造函数，首先会通过调用原型方法_init执行实例化的过程。而对于computed和watch的处理，就在_init函数中。<br>在init中，执行了一系列对传入的options初始化的过程。其中，执行了initState的函数。在initState函数中，有对computed和watch的处理。不仅如此，还包含了对data，methods，props的处理<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (opts.computed) initComputed(vm, opts.computed)</span><br><span class="line"><span class="keyword">if</span> (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123;</span><br><span class="line">    initWatch(vm, opts.watch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实对于computed和watch的处理，差别不大。最后都生成了watcher实例。当相应的数据发生变化时，通知对应的watcher实例执行更新。</p>
<h4 id="下面来分析下computed的处理过程-服务端渲染暂不做分析-。"><a href="#下面来分析下computed的处理过程-服务端渲染暂不做分析-。" class="headerlink" title="下面来分析下computed的处理过程(服务端渲染暂不做分析)。"></a>下面来分析下computed的处理过程(服务端渲染暂不做分析)。</h4><p>首先，大致说下处理流程。</p>
<p>initComputed -&gt; computed watcher(vm, get, {lazy: true}) -&gt; defineComputed(vm, key, userDef)</p>
<p>其中，处理computed的核心就在于initComputed中。在initComputed中，大致执行了以下四个过程：</p>
<ol>
<li>在vm上挂载_computedWatchers。</li>
<li>遍历computed，从userdef中获取getter</li>
<li>生成computed watcher(vm, getter, noop, { lazy: true })</li>
<li>定义vm[key]的get和set。通过执行defineComputed(vm, key, userDef)实现 // 在子实例上会提前执行。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initComputed</span> (<span class="params">vm: Component, computed: Object</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 第一步 在vm上挂载_computedWatchers</span></span><br><span class="line">  <span class="keyword">const</span> watchers = vm._computedWatchers = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  <span class="comment">// computed properties are just getters during SSR</span></span><br><span class="line">  <span class="keyword">const</span> isSSR = isServerRendering()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第二步 遍历computed，从userdef中获取getter</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> computed) &#123;</span><br><span class="line">    <span class="keyword">const</span> userDef = computed[key]</span><br><span class="line">    <span class="keyword">const</span> getter = <span class="keyword">typeof</span> userDef === <span class="string">'function'</span> ? userDef : userDef.get</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; getter == <span class="literal">null</span>) &#123;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">`Getter is missing for computed property "<span class="subst">$&#123;key&#125;</span>".`</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isSSR) &#123;</span><br><span class="line">      <span class="comment">// create internal watcher for the computed property.</span></span><br><span class="line">      <span class="comment">// 第三步 生成computed watcher(vm, getter, noop, &#123; lazy: true &#125;)</span></span><br><span class="line">      watchers[key] = <span class="keyword">new</span> Watcher(</span><br><span class="line">        vm,</span><br><span class="line">        getter || noop,</span><br><span class="line">        noop,</span><br><span class="line">        computedWatcherOptions</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// component-defined computed properties are already defined on the</span></span><br><span class="line">    <span class="comment">// component prototype. We only need to define computed properties defined</span></span><br><span class="line">    <span class="comment">// at instantiation here.</span></span><br><span class="line">    <span class="keyword">if</span> (!(key <span class="keyword">in</span> vm)) &#123;</span><br><span class="line">      <span class="comment">// 第四步 定义vm[key]的get和set</span></span><br><span class="line">      defineComputed(vm, key, userDef)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (key <span class="keyword">in</span> vm.$data) &#123;</span><br><span class="line">        warn(<span class="string">`The computed property "<span class="subst">$&#123;key&#125;</span>" is already defined in data.`</span>, vm)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vm.$options.props &amp;&amp; key <span class="keyword">in</span> vm.$options.props) &#123;</span><br><span class="line">        warn(<span class="string">`The computed property "<span class="subst">$&#123;key&#125;</span>" is already defined as a prop.`</span>, vm)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面来分析下生成computed watcher的过程。</p>
<p>根据传入的参数vm, getter, noop, ，我们可以大致得到这样一个watcher实例：</p>
<pre>
{
    vm: vm,
    getter: getter,
    cb: noop,
    lazy: true,
    dirty: true,
    ...reset
}
</pre>

<p>在watcher实例初始化的过程中，会对实例挂载一系列的属性。由于this.lazy是true，所以初始化时得到的 this.value = undefined。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 来自 watcher.js</span></span><br><span class="line"><span class="keyword">this</span>.value = <span class="keyword">this</span>.lazy</span><br><span class="line">      ? <span class="literal">undefined</span></span><br><span class="line">      : <span class="keyword">this</span>.get()</span><br></pre></td></tr></table></figure></p>
<p>这样computed的初始化就完成了。</p>
<p>假设html模板中用到了computed中的值。在Vue实例init的最后，会调用vm.$mount方法，进而执行到mountComponent函数，mountComponent会生成一个渲染watcher实例。</p>
<p>当render watcher执行时，会访问到计算属性的值，进而会触发计算属性的get。计算属性的get在defineComputed中已经定义过了，如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComputedGetter</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">computedGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> watcher = <span class="keyword">this</span>._computedWatchers &amp;&amp; <span class="keyword">this</span>._computedWatchers[key]</span><br><span class="line">    <span class="keyword">if</span> (watcher) &#123;</span><br><span class="line">      <span class="keyword">if</span> (watcher.dirty) &#123;</span><br><span class="line">        watcher.evaluate()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        watcher.depend()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> watcher.value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后会执行computedGetter。此时，watcher存在，且watcher.dirty为true。会执行watcher.evaluate获得计算属性的值。而在evaluate中，会调用watcher.get方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选自 watcher.js</span></span><br><span class="line">evaluate () &#123;</span><br><span class="line">  <span class="keyword">this</span>.value = <span class="keyword">this</span>.get()</span><br><span class="line">  <span class="keyword">this</span>.dirty = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在执行watcher.get方法时，会将Dep.target设置成当前的watcher, 并调用计算属性的函数。即实例中computedA所对应的函数。在执行这个函数时，又会访问到data中a的值，也即是vm[a]的值。而在vue的响应式系统中，在初始化时对data中的数据进行了响应式观测，并定义了get和set函数，生成了对应的依赖收集器dep。</p>
<p>此时, 计算属性在计算时访问到了vm[a]，触发了vm[a]对应的dep进行依赖收集。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 来自 observer/index.js defineReactive</span></span><br><span class="line"><span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line"><span class="comment">// Dep.target此时为computed watcher。</span></span><br><span class="line"><span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">    <span class="comment">// 使得computed watcher和dep互相添加对方</span></span><br><span class="line">    dep.depend()</span><br><span class="line">    <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">      childOb.dep.depend()</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">        dependArray(value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">return</span> value</span><br></pre></td></tr></table></figure></p>
<p>这样，vm[a]的dep就有了computed watcher。当vm[a]发生变动时，就能够通知到computed watcher。</p>
<p>当computed watcher的evaluate执行完后，Dep.target会变成render watcher。dirty会被置为false。接着往下进行，会执行到watcher.depend(watcher是computed watcher)。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 来自 watcher.js</span></span><br><span class="line">depend () &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="keyword">this</span>.deps.length</span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="keyword">this</span>.deps[i].depend()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此时，depend函数会把刚才computed watcher添加的deps也添加到render watcher中去，使得vm[a]的dep和render watcher也能互相添加到彼此。这样，当vm[a]发生变化时，render watcher也会执行。</p>
<p>当watcher.depend执行完后，返回watcher.value。此时，computed watcher就完成了一次计算过程。</p>
<p>当vm[a]发生变化时，会触发其dep的set。进而触发dep.notify。此时，dep.subs中有两个watcher实例。一个是computed watcher，另一个是render watcher。首先执行computed watcher的update，然后执行render watcher的update。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from watcher.js</span></span><br><span class="line">update () &#123;</span><br><span class="line">  <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.lazy) &#123;</span><br><span class="line">    <span class="comment">// computed watcher会走到这里</span></span><br><span class="line">    <span class="keyword">this</span>.dirty = <span class="literal">true</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sync) &#123;</span><br><span class="line">    <span class="keyword">this</span>.run()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// render watcher会走到这里</span></span><br><span class="line">    queueWatcher(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>computed watcher的update只是简单地把dirty置为了true，以便在下次访问到计算属性时，通过执行evaluate来计算最新的值。</p>
<p>render watcher会被放入执行队列中。将当前主线程代码执行完毕后，在下一次事件循环中执行。</p>
<p>最终，随着render watcher.get的执行，计算属性会被重新获取，进而触发计算属性的getter，然后通过执行computed watcher的evaluate重新获取计算属性的最新值并返回。</p>
<p>以上就是computed的大致执行过程和数据更新过程。</p>
<hr>
<p>下面来分析下watch的执行过程。</p>
<p>从initWatch开始讲起。Vue -&gt; _init -&gt; initState -&gt; initWatch</p>
<p>在initWatch中，主要做了下面几件事：</p>
<ol>
<li>遍历watch配置项，调用createWatcher(vm, key, val);</li>
<li>在createWatcher中对watcher的参数进行格式化，统一格式，然后调用Vue原型方法$watch。</li>
<li>在$watch中，创建user watcher(vm, expOrFn, cb, { user: true, immediate })。如果配置项中有immediate且为true，在user watcher初始化后，立即调用一次val，即观察数据发生变化后配置的回调函数。之后，返回一个销毁该watcher的函数。</li>
</ol>
<p>watch最终会创建user watcher。下面我们用一个例子来分析下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            a: <span class="number">1</span>,</span><br><span class="line">            b: &#123;</span><br><span class="line">                c: <span class="number">2</span>,</span><br><span class="line">                d: &#123;</span><br><span class="line">                    e: <span class="number">5</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    computed: &#123;</span><br><span class="line">        computedA() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="number">10</span>;</span><br><span class="line">        &#125;,        </span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    watch: &#123;</span><br><span class="line">        computedA(newVal, oldVal) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(newVal);</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        a(newVal, oldVal) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(newVal);</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        b: &#123;</span><br><span class="line">            deep: <span class="literal">true</span>,</span><br><span class="line">            handler(newVal) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(newVal);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>三个watch对应了三种不同的观察对象。</p>
<h4 id="下面先介绍一般情况，即watch中对a的观测。"><a href="#下面先介绍一般情况，即watch中对a的观测。" class="headerlink" title="下面先介绍一般情况，即watch中对a的观测。"></a>下面先介绍一般情况，即watch中对a的观测。</h4><ul>
<li>首先，在initWatcher时，通过for in 遍历，会直接进入到createWatcher中；</li>
<li>然后，在createWatcher中，由于handle就是普通的function，所以会直接进入vm.$watch中。</li>
<li>之后，在$watch中，创建user watcher(vm, ‘a’, fn, { user: true });</li>
<li>最后，会进入user watcher实例初始化的过程。最终，生成了一个数据a的user watcher。大致如下：<pre>
{
  vm: vm,
  getter: fn, // 由parsePath生成的
  cb: noop,
  lazy: false,
  user: true,
  ...reset
}
</pre>

</li>
</ul>
<p>在user watcher生成最后，会调用watcher.get方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from watcher.js constructor</span></span><br><span class="line"><span class="keyword">this</span>.value = <span class="keyword">this</span>.lazy</span><br><span class="line">  ? <span class="literal">undefined</span></span><br><span class="line">  : <span class="keyword">this</span>.get()</span><br></pre></td></tr></table></figure></p>
<p>进入watcher.get方法后，会将当前的Dep.target设置为当前user watcher。</p>
<p>此时，调用watcher.getter，会访问到vm[‘a’]，而vm[‘a’]在之前的initData中被observe并且设置了getter和setter，此时会触发vm[‘a’]的getter。vm[‘a’]的dep和当前的user watcher会通过dep.depend互相添加，vm[‘a’]的dep的subs中有该user watcher，该user watcher的newDeps中也会有vm[‘a’]的dep。</p>
<p>当vm[‘a’]发生变化时，会触发vm[‘a’]的setter，进而vm[‘a’]的deps调用notify方法，然后调用之前添加user watcher的update方法，被添加到queueWatcher中。</p>
<p>最终，随着任务队列的执行，会执行到user watcher的run方法。之后会调用watcher.get重新求值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from watcher.js run</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当最新计算的值和watcher.value不等或者value是object或者watcher.deep为true时，会执行以下代码</span></span><br><span class="line"><span class="keyword">const</span> oldValue = <span class="keyword">this</span>.value</span><br><span class="line"><span class="keyword">this</span>.value = value</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.user) &#123;</span><br><span class="line">    <span class="comment">// user watcher 会走到这里，因为 watcher.user = true</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, value, oldValue) <span class="comment">// 调用观察数据的回调函数</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        handleError(e, <span class="keyword">this</span>.vm, <span class="string">`callback for watcher "<span class="subst">$&#123;<span class="keyword">this</span>.expression&#125;</span>"`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, value, oldValue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>观察普通值的初始化及数据变动分析到这里就结束了。</p>
<h4 id="下面我们来分析下对computedA的观察。在这里，和普通值观测相同的相同的地方就不细说了，重点说不同的地方。"><a href="#下面我们来分析下对computedA的观察。在这里，和普通值观测相同的相同的地方就不细说了，重点说不同的地方。" class="headerlink" title="下面我们来分析下对computedA的观察。在这里，和普通值观测相同的相同的地方就不细说了，重点说不同的地方。"></a>下面我们来分析下对computedA的观察。在这里，和普通值观测相同的相同的地方就不细说了，重点说不同的地方。</h4><p>不同之处在于生成的user watcher的不同。其实是又回到了计算属性的get过程。</p>
<p>生成user watcher之后，调用watcher.get。此时，会访问到vm[‘computedA’]，而vm[‘computedA’]是一个计算属性，在watch之前已经初始化了一个computed watcher。此时的Dep.target是user watcher。在访问vm[‘computedA’]时，代码会执行到这个地方：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from state.js </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComputedGetter</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">computedGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> watcher = <span class="keyword">this</span>._computedWatchers &amp;&amp; <span class="keyword">this</span>._computedWatchers[key]</span><br><span class="line">    <span class="comment">// 代码会执行到这里</span></span><br><span class="line">    <span class="keyword">if</span> (watcher) &#123;</span><br><span class="line">      <span class="keyword">if</span> (watcher.dirty) &#123;</span><br><span class="line">        <span class="comment">// 通过对computed watcher的重新求值，使得vm['a']的dep中有该computed watcher，该computed watcher的deps中也有vm['a']的dep。</span></span><br><span class="line">        watcher.evaluate()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        <span class="comment">// computed watcher重新求值后，Dep.target会重新退回到user watcher。通过watcher的depend，使得vm['a']的dep和user watcher也互相添加。</span></span><br><span class="line">        watcher.depend()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> watcher.value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当数据vm[‘a’]发生变动时，此时vm[‘a’]的deps中既有computed watcher，也有user watcher。其中computed watcher在前。此时，会分别执行两个watcher的update方法。</p>
<p>computed watcher的update之前已经说过，不再赘述。<br>之后，user watcher会被queueWatcher添加到执行队列。最终执行watcher.run方法。在watcher.run中，访问到了vm[‘computedA’]，此时，重新触发了对vm[‘computedA’]的getter。vmp[‘computedA’]会再次调用watcher.evaluate方法完成求值并返回。此时能够获取到最新的computedA的值，然后执行和观察vm[‘a’]一样的过程，不再详述。</p>
<h4 id="下面说下对b的观察。"><a href="#下面说下对b的观察。" class="headerlink" title="下面说下对b的观察。"></a>下面说下对b的观察。</h4><p>和对a的观察相比，主要的不同主要集中于初始化的createWatcher和watcher.get方法中。除此以外，和观察a的区别不大。</p>
<ol>
<li><p>createWatcher中，handle为object，因此会进入到if分支</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from state.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWatcher</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  vm: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  expOrFn: string | Function,</span></span></span><br><span class="line"><span class="function"><span class="params">  handler: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  options?: Object</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isPlainObject(handler)) &#123;</span><br><span class="line">    <span class="comment">// 会进入到这里，对传入的handle进行处理</span></span><br><span class="line">    options = handler</span><br><span class="line">    handler = handler.handler</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> handler === <span class="string">'string'</span>) &#123;</span><br><span class="line">    handler = vm[handler]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vm.$watch(expOrFn, handler, options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在watcher.get中，有对watcher.deep的处理，即对深度观察的处理。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">get () &#123;</span><br><span class="line">  pushTarget(<span class="keyword">this</span>)</span><br><span class="line">  <span class="keyword">let</span> value</span><br><span class="line">  <span class="keyword">const</span> vm = <span class="keyword">this</span>.vm</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    value = <span class="keyword">this</span>.getter.call(vm, vm)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.user) &#123;</span><br><span class="line">      handleError(e, vm, <span class="string">`getter for watcher "<span class="subst">$&#123;<span class="keyword">this</span>.expression&#125;</span>"`</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> e</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// "touch" every property so they are all tracked as</span></span><br><span class="line">    <span class="comment">// dependencies for deep watching</span></span><br><span class="line">    <span class="comment">// 会进入到下边的if分支。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.deep) &#123;</span><br><span class="line">      traverse(value)</span><br><span class="line">    &#125;</span><br><span class="line">    popTarget()</span><br><span class="line">    <span class="keyword">this</span>.cleanupDeps()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>通过traverse，使得vm[‘b’]下的每一层数据都被访问到了，其对应的dep和当前的b的user watcher都相互添加。最终实现 当vm[‘b’]下任意一层数据变更，都能够通过数据的dep触发notify，进而调用到该user watcher的update方法，从而执行配置的观察回调函数。</p>
<hr>
<p>对watch和computed的讲解分析就先到这里了。能够这样理一遍，也算是有所收获。如果有错误，欢迎指出。谢谢。</p>

      
    </div>
    <footer class="article-footer">
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue/">Vue</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/06/24/微信网页开发踩坑记/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          微信网页开发踩坑记
        
      </div>
    </a>
  
  
    <a href="/2018/12/08/css中float研究/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">css中float研究</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/学习/">学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/实战/">实战</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书/">读书</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Bug/" style="font-size: 10px;">Bug</a> <a href="/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/tags/Promise/" style="font-size: 12.5px;">Promise</a> <a href="/tags/TypeScript/" style="font-size: 10px;">TypeScript</a> <a href="/tags/Vue/" style="font-size: 20px;">Vue</a> <a href="/tags/fullpage/" style="font-size: 10px;">fullpage</a> <a href="/tags/http/" style="font-size: 12.5px;">http</a> <a href="/tags/https/" style="font-size: 10px;">https</a> <a href="/tags/javascript/" style="font-size: 10px;">javascript</a> <a href="/tags/node/" style="font-size: 15px;">node</a> <a href="/tags/全栈/" style="font-size: 10px;">全栈</a> <a href="/tags/前端/" style="font-size: 12.5px;">前端</a> <a href="/tags/博客说明/" style="font-size: 10px;">博客说明</a> <a href="/tags/学习/" style="font-size: 10px;">学习</a> <a href="/tags/工具/" style="font-size: 10px;">工具</a> <a href="/tags/异步/" style="font-size: 10px;">异步</a> <a href="/tags/微信/" style="font-size: 10px;">微信</a> <a href="/tags/数据结构与算法/" style="font-size: 12.5px;">数据结构与算法</a> <a href="/tags/浏览器/" style="font-size: 10px;">浏览器</a> <a href="/tags/计算机基础/" style="font-size: 10px;">计算机基础</a> <a href="/tags/设计模式/" style="font-size: 10px;">设计模式</a> <a href="/tags/面试/" style="font-size: 17.5px;">面试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/06/20/http发展历史/">HTTP发展历史</a>
          </li>
        
          <li>
            <a href="/2020/06/19/charles的原理/">charles的原理</a>
          </li>
        
          <li>
            <a href="/2020/05/25/https为什么比http更安全/">https为什么比http更安全</a>
          </li>
        
          <li>
            <a href="/2019/08/16/从一个日常bug看Vue的列表key及vnode更新策略/">从一个日常bug看Vue的列表key及vnode更新策略</a>
          </li>
        
          <li>
            <a href="/2019/08/14/Vue异步组件探究/">Vue异步组件探究</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer" style="text-align: center;">
  
  <div class="outer">
    <div class="beian">
      <a href="https://beian.miit.gov.cn" target="_blank">豫ICP备16017823号-2</a> &copy; 2021 maxy612
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/interview" class="mobile-nav-link">面试</a>
  
    <a href="/life" class="mobile-nav-link">生活</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about-md" class="mobile-nav-link">关于我</a>
  
</nav>
    

<script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>